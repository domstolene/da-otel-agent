name: Build and publish release

on:
  release:
    types: [created]
  workflow_dispatch:
      release_version:
        type: string
        description: Release version.
        required: false
        default: "1.0.0"

jobs:
  build:

    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - uses: actions/checkout@v3
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Gradle validate wrapper
      uses: gradle/wrapper-validation-action@v1

    - name: Gradle build agent and service
      uses: gradle/gradle-build-action@v2
      with:
        gradle-version: wrapper
        arguments: build --no-daemon -PGITHUB_TOKEN=${{ secrets.CR_PAT }} -PGITHUB_ACTOR=${{ github.actor }}

    - name: Gradle publish agent
      uses: gradle/gradle-build-action@v2
      with:
        gradle-version: wrapper
        arguments: publish --no-daemon -PGITHUB_TOKEN=${{ secrets.CR_PAT }} -PGITHUB_ACTOR=${{ github.actor }}

    # Get name of (single) artefact.
    - name: Get service JAR filename
      id: get-jarname
      run: |
        export JAR_NAME="$(basename $(ls service/build/libs/*.jar))"
        echo "jar is $JAR_NAME"
        echo "::set-output name=jarname::$JAR_NAME"
        echo "JAR_NAME=$JAR_NAME" >> $GITHUB_ENV

    # Upload artefact for use in next job.
    - uses: actions/upload-artifact@v3
      with:
        name: ${{ env.JAR_NAME }}
        path: target/${{ env.JAR_NAME }}
        if-no-files-found: error
          
  # Build and publish container image.
  build-push-image:
    name: Build and push
    runs-on: ubuntu-latest
    needs: build
    env:
      # Name of JAR file to be packaged in container image.
      JAR_NAME: ${{ needs.compile-test.outputs.jarname }}
      # Name of base image to be used with s2i.
      BASE_IMAGE: registry.access.redhat.com/ubi8/openjdk-17
      # The registry we will push to
      REGISTRY: ghcr.io
      # Name of the GitHub repository,
      IMAGE_NAME: ${{ github.repository }}
    steps:
      # Download the JAR artefact from the compile step.
      - uses: actions/download-artifact@v3
        with:
          name: ${{ env.JAR_NAME }}

      # Log in to the GitHub Container Registry
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.CR_PAT }}

      # Obtain useful metadata for tagging and labeling of the resulting image
      - name: Obtain Docker metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          flavor: latest=auto
          tags: |
            type=semver,pattern={{version}},prefix=
            type=semver,pattern={{major}}.{{minor}},prefix=
      # Tags generated by the Docker utility does not have a format that
      # s2i-build likes, so we remove the prefixing registry and image names
      # to end up with only the actual tags. Likewise we handle the labels so
      # they can be set
      - name: Reformat metadata for s2i
        id: trim
        run: |
          echo '${{steps.meta.outputs.json}}' > metadata.json
          jq -r '.tags[]' metadata.json | sed 's/^.*:\(.*\)$/\1/' | tr -s '\n' ' ' > tags.txt
          export TAGS="$(cat tags.txt)"
          echo "::set-output name=tags::$TAGS"
          echo "TAGS=$TAGS" >> $GITHUB_ENV
          export RELEASE=$(echo $TAGS | cut -d " " -f1)
          echo "RELEASE=$RELEASE" >> $GITHUB_ENV
      # Setup S2i and build container image.
      - name: Configure and build image using s2i
        id: build_image
        uses: redhat-actions/s2i-build@v2
        with:
          # Builder image for a Java project.
          builder_image: ${{ env.BASE_IMAGE }}
          # domstolene/template-java
          image: ${{ env.IMAGE_NAME }}
          # Multiple tags does not work here, despite documentation stating
          # otherwise - so we set the "latest" tag and fix the others later
          tags: "latest"

      # Set the labels that s2i-build could not handle
      - name: Add missing labels to image
        id: labelfix
        run: |
          jq -r '.labels|to_entries|map("\(.key)=\"\(.value)\"")|.[]' metadata.json > labels.txt
          IFS=$'\n'
          LABELS=$(cat labels.txt)
          for LABEL in $LABELS
          do
            echo "FROM ${{ env.IMAGE_NAME }}" | docker build --label $LABEL -t ${{ env.IMAGE_NAME }} -
          done
      # Set the tags that s2i-build could not handle
      - name: Add missing tags to image
        id: tagfix
        run: |
          for TAG in ${{ env.TAGS }}
          do
            docker tag ${{ env.IMAGE_NAME }} ${{ env.IMAGE_NAME }}:$TAG
          done
      # Push Image to Github Container Registry
      # Docker-imaget har tags dersom workflowen trigges av release
      - name: Push to registry with tags
        if: ${{ steps.trim.outputs.tags != '' }}
        uses: redhat-actions/push-to-registry@v2
        with:
          image: ${{ steps.build_image.outputs.image }}
          registry: ${{ env.REGISTRY }}
          tags: ${{ steps.trim.outputs.tags }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.CR_PAT }}

      # Docker-imaget har ikke tags dersom workflowen trigges av workflow-dispatch
      - name: Push to registry without tags
        if: ${{ steps.trim.outputs.tags == '' }}
        uses: redhat-actions/push-to-registry@v2
        with:
          image: ${{ steps.build_image.outputs.image }}
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.CR_PAT }}

      - name: Checkout k8s-applications
        uses: actions/checkout@v3
        with:
          repository: domstolene/k8s-applications
          ref: main
          token: ${{ secrets.CR_PAT }}

      # Create a new pull request in the infrastructure repository for
      # publishing a new version of the application.
#      - name: Create pull request for updating deployment
#        if: ${{ github.event.release.tag_name }}
#        run: |
#          for ENV in "AT" "PROD"
#          do
#            env_lower_case=$(echo $ENV | tr '[:upper:]' '[:lower:]')
#            export PR_BRANCH="deploy-$env_lower_case-${{ steps.build_image.outputs.image }}-${{ github.event.release.tag_name }}-runid-${{github.run_id}}"
#            git checkout -b $PR_BRANCH main
#            sed -i "s/newTag: .*/newTag: \"${{ env.RELEASE }}\"/g" applications/doedsfall/$env_lower_case/kustomization.yaml
#            git add .
#            git -c user.name="${{ github.actor }}" commit -m"Deploy ${{ steps.build_image.outputs.image }} ${{ github.event.release.tag_name }} to $ENV"
#            git push --set-upstream origin $PR_BRANCH
#            echo ${{ secrets.REPO_PAT }} | gh auth login --with-token
#            gh pr create --draft --head $PR_BRANCH --base main --assignee ${{ github.actor }} --title "Deploy ${{ steps.build_image.outputs.image }} ${{ github.event.release.tag_name }} to $ENV" --body "${{ github.event.release.body }}"
#          done
